main source: https://www.freecodecamp.org/news/what-is-a-pure-function-in-javascript-acb887375dfe/

# Checklist:

1. SAME INPUT -> SAME OUTPUT 
    Same input ALWAYS returns same output: consistent results

2. NO SIDE EFFECTS
    Examples of side-effects:
        -mutating input
        -HTTP calls(AJAX/fetch)
        -Changing the filesystem(fs) / writing to disk
        -Querying the DOM

    ->Basically, any work a fn does that's not related to calculating the final 
      output

    ->console.log - not so bad, but...

    ->IMPURELY changing an object is.
      e. g.
      <code>
        // “Impurely” Changing an Object
        const impureAssoc = (key, value, object) => {
        object[key] = value;
        };

        const person = {
            name: 'Bobo'
        };

        const result = impureAssoc('shoeSize', 400, person);

        console.log({
            person,
            result
        });
        /* The variable, person, has been forever changed because our function
        introduced an assignment statement. Shared state means impureAssoc's
        impact isn’t fully obvious anymore. */
      </code>

      Sometimes we can purify a fn by simply returning a new object with our desired properties, e.g.
      
      <code>
        const pureAssoc = (key, value, object) => {
            const newObject = { ...object };

            newObject[key] = value;

            return newObject;
            // mutation’s limited to that small scope and you’re still returning
            // a value.
        };

        const person = {
            name: 'Bobo'
        };

        const result = pureAssoc('shoeSize', 400, person);

        console.log({
            person,
            result
        });
        </code>

    ->Mutating your input can be dangerous, but mutating a copy of it is no
      problem.

    ->The spread operator (...) creates a shallow copy of an object,
      and shallow copies aren't safe from nested mutations.
      Example of UNSAFE NESTED MUTATION:
      <code>
        const person = {
            name: 'Bobo',
            address: { street: 'Main Street', number: 123 }
        };

        const shallowPersonClone = { ...person };
        shallowPersonClone.address.number = 456;

        console.log({ person, shallowPersonClone });
      </code>

      SAFE NESTED MUTATION USING DEEP CLONE
      -------------------------------------
      <code>
        const person = {
            name: 'Bobo',
            address: { street: 'Main Street', number: 123 }
        };

        const deepPersonClone = JSON.parse(JSON.stringify(person));
        deepPersonClone.address.number = 456;

        console.log({ person, deepPersonClone });
      </code>

#######
SUMMARY
#######
A function’s pure if it’s free from side-effects and returns the same output, given the same input.

Side-effects include: mutating input, HTTP calls, writing to disk, printing to the screen.

You can safely clone, then mutate, your input. Just leave the original one untouched.

Spread syntax (… syntax) is the easiest way to shallowly clone objects.

JSON.parse(JSON.stringify(object)) is the easiest way to deeply clone objects. 

#########
WHY PURE?
#########
Pure functions are the atomic building blocks in functional programming. 
They are adored for their simplicity and testability.